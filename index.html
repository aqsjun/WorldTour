<!DOCTYPE html>
  <html>
  <head>
    <title>Top US Immigrant Birth Countries 2016</title>
      <link rel="icon" href="icon.png" >
  <meta charset="utf-8">
  <style>

  h1 {
  position: absolute;
  top: 500px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 21px;
  text-align: center;
  width: 960px;
  }

  </style>
  </head>

  <body>
  <h1></h1>
  <script src="https://d3js.org/d3.v3.min.js"></script>
  <script src="https://d3js.org/queue.v1.min.js"></script>
  <script src="https://d3js.org/topojson.v1.min.js"></script>
  <script>

  // Define the function for the world feature

        var width = 960,
            height = 960;

        var projection = d3.geo.orthographic() // Define the projection by using orthographic data from D3
            .translate([width / 2, height / 2])
            .scale(width / 2 - 20)
            .clipAngle(90)
            .precision(0.6);

        var canvas = d3.select("body").append("canvas")
            .attr("width", width)
            .attr("height", height);

        var c = canvas.node().getContext("2d");

        var path = d3.geo.path()// Define the projection by using path data from D3
            .projection(projection)
            .context(c);

        var title = d3.select("h1");

        queue()
          .defer(d3.json, "world-110m.json")
          .defer(d3.tsv, "world_data.txt")
            .await(ready);


        function ready(error, world, names) {
          if (error) throw error;

          var globe = {type: "Sphere"},// Define the type of map (in this case we chose to use sphere)
              land = topojson.feature(world, world.objects.land),// Define the TopoJSON using data from D3 (Mike Bostock)
              countries = topojson.feature(world, world.objects.countries).features,// Define the countries name using data from D3 (Mike Bostock)
              borders = topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }),// Define the countries' borders location using data from D3 (Mike Bostock)
              i = -1,
              n = countries.length;

          countries = countries.filter(function(d) {
            return names.some(function(n) {
              if (d.id == n.id) return d.name = n.name;
            });
          }).sort(function(a, b) {
            return a.name.localeCompare(b.name);
          });

          (function transition() {
            d3.transition()
                .duration(1000)// Define the speed of duration between countries (lower the number will increse the speed of the time span between each coutnries and higher the number will decrease the speed of the time span)
                .each("start", function() {
                  title.text(countries[i = (i + 1) % n].name);
                })
                .tween("rotate", function() {
                  var p = d3.geo.centroid(countries[i]),
                      r = d3.interpolate(projection.rotate(), [-p[0], -p[1]]);
                  return function(t) {
                    projection.rotate(r(t));
                    c.clearRect(0, 0, width, height);
                    c.fillStyle = "#a6dba0", c.beginPath(), path(land), c.fill();
                    c.fillStyle = "#7b3294", c.beginPath(), path(countries[i]), c.fill();
                    c.strokeStyle = "#c2a5cf", c.lineWidth = 1, c.beginPath(), path(borders), c.stroke();
                    c.strokeStyle = "#000000", c.lineWidth = 2, c.beginPath(), path(globe), c.stroke();
                  };
                })
              .transition()
                .each("end", transition);
          })();
        }

        d3.select(self.frameElement).style("height", height + "px");
  </script>
  </body>
  </html>
